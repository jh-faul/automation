import argparse
import json
import logging
import os
import re
import subprocess

import yaml

log = logging.getLogger(__name__)


def ansible_remove_ansi_escape_sequences(input_string: str):
    """
    Remove ANSI escape sequences from the input string.

    Parameters
    ----------
    input_string : str
        The string containing ANSI escape sequences to be removed.

    Returns
    -------
    str
        The input string with ANSI escape sequences removed.

    Notes
    -----
    This function uses a regular expression to find and remove ANSI escape sequences
    from the input string. These sequences are commonly used for formatting output in
    terminal applications, such as those generated by Ansible.
    """
    ansi_escape = re.compile(r'\x1b\[([0-9]{1,2}(;[0-9]{1,2})*)?[m|K]')
    return ansi_escape.sub('', input_string)


def filter_passwords(input_string):
    """
    Filter out passwords from the input string.

    Parameters
    ----------
    input_string : str
        The string in which passwords need to be filtered.

    Returns
    -------
    str
        The input string with passwords replaced by asterisks.

    Notes
    -----
    This function uses a regular expression to find occurrences of the word "password"
    followed by an equal sign and the corresponding password. It then replaces the password
    with asterisks. This is useful for sanitizing sensitive information from
    log files or other textual data.
    """
    # Regular expression to find the word "password" and the corresponding password
    pattern = re.compile(r'(password\s+|password\s*=\s*)(\S+)')

    def replace_password(match):
        match.group(1)
        return 'password=****'
    # Replace passwords in the input string
    filtered_string = pattern.sub(replace_password, input_string)
    return filtered_string


def ansible_log_writer_analyzer(log_name: str, command: str, log_level: str = 'INFO') -> bool:
    """
    Execute a shell command and write the output to a log file. Return True if the command
    executes successfully (i.e., exits with a zero exit code), otherwise return False.

    Parameters
    ----------
    log_name : str
        The name of the log file.
    command : str
        The command to be executed.
    log_level : str, optional
        The logging level (default is 'INFO').

    Returns
    -------
    bool
        True if the command executed successfully, False otherwise.

    Notes
    -----
    This function executes the specified shell command using `subprocess.Popen` and captures its
    stdout and stderr outputs. It writes the command details, exit code, stdout, and stderr to
    the log file. If any failures are detected in the command output (e.g., unreachable hosts or failed tasks),
    the function returns False. If log_level is set to 'VERBOSE', detailed process information is written to the log.
    """
    process_info = {}
    with open(log_name, 'a') as f:
        process = subprocess.Popen(
            command, shell=True, stdin=subprocess.PIPE,
            stdout=subprocess.PIPE, stderr=subprocess.PIPE, encoding='utf-8',
        )

        stdout, stderr = process.communicate()
        output = ansible_remove_ansi_escape_sequences(stdout)

        log.debug(output)

        # Store process details in the dictionary
        process_info['command'] = filter_passwords(command)
        process_info['exit_code'] = process.returncode
        process_info['stdout'] = filter_passwords(output)
        process_info['stderr'] = filter_passwords(stderr)

        # Serialize process_info dictionary to JSON
        process_info_str = json.dumps(process_info, indent=4)

        pattern = r'(unreachable=1|failed=1|Traceback)'
        # Find all matches with capturing groups
        matches = re.findall(pattern, output)

        if log_level == 'VERBOSE':
            f.write(process_info_str)
            f.write('\n')

        log.debug(f'matches {matches}')

        f.write(process_info_str)
        f.write('\n')

        if stderr != '':
            log.error('Execution Failure')
            f.write(process_info_str)
            f.write('\n')
            return True

        # Check if matches list is empty
        if len(matches) == 0:
            log.info('No failures detected.')
            return False
        else:
            # Write serialized process_info to the log file
            log.warning('Failures were detected.')
            # Only write out the failures
            if log_level != 'VERBOSE':
                f.write(process_info_str)
                f.write('\n')
            return True


def ansible_run_check(log_check_bool: list[bool]) -> bool:
    """
    Check a list of boolean values and return True if all values are False,
    otherwise return False.

    Parameters
    ----------
    log_check_bool : List[bool]
        A list of boolean values.

    Returns
    -------
    bool
        True if all values in the list are False, otherwise False.

    Notes
    -----
    This function checks each boolean value in the provided list. If any of the values
    are True, indicating that at least one condition is met, the function returns False.
    Otherwise, if all values are False, the function returns True. This function is useful
    for checking the status of multiple conditions before proceeding with further actions.
    """
    log.debug(
        f'log_check_bool: {log_check_bool} | any(log_check_bool): {any(log_check_bool)}',
    )
    if any(log_check_bool):
        return True
    else:
        return False


def ansible_inventory_manager(identifier: str, hostname: str, username: str, password: str, inventory_directory: str, **kwargs):
    """
    Update the Ansible inventory file with the provided host information.

    Parameters
    ----------
    identifier : str
        The identifier for the host entry.
    hostname : str
        The hostname of the host.
    username : str
        The username for SSH authentication.
    password : str
        The password for SSH authentication.
    inventory_directory : str
        The path to the directory containing the Ansible inventory file.

    Returns
    -------
    None

    Notes
    -----
    This function updates the Ansible inventory file located at `inventory_directory` with the provided
    host information. If the `identifier` already exists in the YAML file, it logs a message indicating
    that the field already exists. Otherwise, it adds a new entry to the inventory file with the specified
    `identifier`, `hostname`, `username`, and `password`. The function does not return any value.
    """
    try:
        # Load existing YAML file
        with open(inventory_directory) as f:
            existing_data = yaml.safe_load(f)
        # Handle for empty file
        existing_data = existing_data or {}
        # Handle for existing entries
        if identifier in existing_data:
            log.info('The identifier field already exists in the YAML file.')
        else:
            # Update existing data with new dictionary
            new_data = {
                f'{identifier}': {
                    'hosts': {
                        f'{hostname}': {
                            'ansible_user': f'{username}',
                            'ansible_ssh_pass': f'{password}',
                        },
                    },
                },
            }
            existing_data.update(new_data)

            # Append updated data to YAML file
            with open(inventory_directory, 'w') as f:
                yaml.dump(existing_data, f)
        return True
    except Exception as ex:
        log.exception(ex)
        return False


def ansible_add_to_inventory(identifier: str, hostname: str, username: str, password: str, inventory_directory: str, *args, **kwargs):
    r"""
    Add host information to the Ansible inventory file, supporting multiprocessing safety.

    Parameters
    ----------
    identifier : str
        The identifier for the host entry.
    hostname : str
        The hostname of the host.
    username : str
        The username for SSH authentication.
    password : str
        The password for SSH authentication.
    inventory_directory : str
        The path to the directory containing the Ansible inventory file.
    *args
        Additional positional arguments (not used).
    **kwargs
        Additional keyword arguments:
        - lock: A multiprocessing lock to ensure thread safety.

    Returns
    -------
    None

    Notes
    -----
    This function adds host information to the Ansible inventory file located at `inventory_directory`.
    If a `lock` is provided in the `kwargs` dictionary, the function acquires the lock before calling
    `ansible_inventory_manager` to ensure thread safety in multiprocessing environments.
    """
    # Multi processing safe
    lock = kwargs.get('lock', None)
    if lock:
        with lock:
            return ansible_inventory_manager(
                identifier, hostname, username, password, inventory_directory, **kwargs,
            )
    else:
        return ansible_inventory_manager(
            identifier, hostname, username, password, inventory_directory, **kwargs,
        )


def ansible_add_to_inventory_executor(hostname, username, password, **kwargs):

    identifier = hostname + '-deployed'
    if kwargs.get('use_docker', False):
        inventory_directory = '/etc/ansible/hosts/main.yml'
        ansible_add_to_inventory_args_parser = f'python3 ansible.py --identifier {identifier} --hostname {hostname} --username {username} --password {password} --inventory_directory {inventory_directory}'
        ansible_add_to_inventory_command = f'docker exec -t {kwargs["docker_name"]} {ansible_add_to_inventory_args_parser}'
        if kwargs.get('install_log_name') is not None and kwargs.get('log_level'):
            # Because it is inverted logic for when it fails
            return not ansible_log_writer_analyzer(
                kwargs['install_log_name'], ansible_add_to_inventory_command, kwargs['log_level'],
            )
        else:
            raise Exception(
                'install_log_name and log_level are required kwargs when using docker',
            )
    else:
        cwd = os.getcwd()
        inventory_directory = os.path.join(
            cwd, '../ansible/inventory/main.yml',
        )

        # Write the hypervisor to the hosts file if it does not exist
        return ansible_add_to_inventory(
            identifier=identifier,
            hostname=hostname,
            username=username,
            password=password,
            inventory_directory=inventory_directory,
        )


def ansible_ssh_key_exist(directory, key_name):
    key_path = os.path.join(directory, key_name)
    if os.path.exists(key_path):
        return True
    else:
        return False


def ansible_ssh_keys_generate(directory, key_name):
    key_path = os.path.join(directory, key_name)
    # Check if directory exists
    if not os.path.exists(directory):
        os.makedirs(directory, exist_ok=True)

    # Generate SSH key pair
    subprocess.run([
        'ssh-keygen', '-t', 'rsa', '-b',
        '4096', '-f', key_path, '-N', '',
    ])
    log.info('SSH keys generated successfully.')


def execute_ansible_add_to_inventory():
    parser = argparse.ArgumentParser(
        description='Execute ansible_add_to_inventory function',
    )
    parser.add_argument(
        '--identifier', type=str,
        help='The identifier for the host entry',
    )
    parser.add_argument(
        '--hostname', type=str,
        help='The hostname of the host',
    )
    parser.add_argument(
        '--username', type=str,
        help='The username for SSH authentication',
    )
    parser.add_argument(
        '--password', type=str,
        help='The password for SSH authentication',
    )
    parser.add_argument(
        '--inventory_directory', type=str,
        help='The directory for the ansible inventory file',
    )
    args = parser.parse_args()
    ansible_add_to_inventory(
        args.identifier, args.hostname,
        args.username, args.password, args.inventory_directory,
    )


if __name__ == '__main__':
    execute_ansible_add_to_inventory()
